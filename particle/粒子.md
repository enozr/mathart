#粒子系统
---------------------------------
一种观点说，世界是一群相互作用的粒子(原子)，不管啥东西，本质上就是一堆点。现实点说，屏幕就是一堆像素点，无论电视里放什么，归根结底就是一群会发光的点在变颜色。

电脑里我们可以把点画出来，单个点是粒子，一群点是粒子系统(particle system), 我们常常用粒子系统去模拟液体急速的湍流、燃烧的火焰，鸟群的飞翔，甚至动作片巨大的爆炸。有时我们看到点群丰富的聚集状态、有时感受到点群难易言说的运动节奏、有时我们压根就没发现这是一群点，海量点群体的特征给我们带来了现实的感受。

如何做出粒子系统？

##物理模拟
---------------------------------
创造粒子系统，最直观的是用物理规律模拟现实。

所有物体都在物理定律下相互作用，中学我们就知道: 世界像一台巨大的机器，所有物体都受力学规则的支配，地球上所有物体都有向下的吸引，行进中总会遭遇逆反的阻力，被弹簧拉着的小球永远受到面朝弹簧中心的拉力，而无论绕太阳椭圆运动的地球，还是沿着抛物线或双曲线行走的彗星，都是万有引力的杰作。

面对复杂的情况，先是万变不离其宗的受力分析。对于每个受力的物体，我们算此刻的受力总和(这种相加就是矢量的相加),根据受到得合力，我们就能计算物体的运动:
受力的物体会产生加速度，我们通过牛顿第二定律 f = ma 算出加速度，加速度累加在速度上，速度累加到位置上，知道了所有的点的位置，物理题一般就解完了（我们也可以在电脑上把结果画出来了）。

通常中学的题目里，我们遭遇的都是恒力，我们通过一些简单的方法去计算位置，可事实上，自然界是如此复杂，受力无时不刻变化，加速度、速度、位置也是如此，复杂性足够搞晕我们战斗力渣渣的肉脑。直到后来牛顿莱布尼兹发明了微积分（微元法），研究了一套对瞬间的累加计算的方法论，并得到解析的结果(结果用函数表示，理论上无限精确)。在微积分野蛮生长的17-18世纪，数学家的信心逐渐爆棚，比如拉普拉斯说，告诉我宇宙中每个粒子的位置速度和现在的时间，我可以(解微分方程)计算宇宙的历史和未来。这么理解，我思考这句话本身也是脑细胞的运动(一堆粒子互相作用)，是可以计算的。如果拉普拉斯足够吊，就可以预言200年后我在思考他说的话！

<!-- 拉普拉斯的话导致很多人相信宿命论，反正粒子的运动确定，物理定律确定，未来是确定的，这就是著名的。有许多方式驳斥拉普拉斯，除了混沌和不确定性原理，计算本身还必须靠物质，计算机的计算力能足以算准组成自己的原子的运动嘛？ -->

世界就是个巨大的、受力学支配的粒子系统，只要超级大的计算能力就能算出未来。这导致很多人相信宿命论（科学宿命论，未来是可计算的)。可对复杂的世界，微积分的表现力很有限，比如微积分解物理题，往往先列一组微分方程，然后慢慢解，但有很多无解(无初等函数解)的方程。还有后续混沌效应、量子级别的不确定性，还有计算本身就需要消耗大量物质...我相信我们永远不能从世界这个巨大的粒子系统里解出未来。还是从离题中回来吧。

虽然微分方程难解，但计算机是可以硬算滴, 近似一下，立马算完，要什么微分方程，高中物理加一点线性代数就已足够（牛顿蜀黍已哭晕有木有）！

虽然力、加速度、速度和位移都随着时间变化，但我们可以把时间切碎，分成一个个很短暂周期，对个周期，设时间间隔为dt，对于每个粒子，执行以下步骤：

1. 算受力：把所有受力加起来算个和(如引力、弹力、阻力、粒子间互相作用力等等)
2. 算加速度：通过受力规则(如f = ma)， 根据粒子的质量，算出粒子的加速度，
3. 算速度：通过加速度，更新粒子对象存储的速度 v = a * dt。
4. 算位置：更新粒子对象存储的w位置 s = v * dt。
5. 画出来：根据现在粒子的位置，把粒子在屏幕上画出来。
我们可以把1-4理解成模拟阶段（Simulation stage），也就是只算数字，不画出来， 然后第五步是绘图阶段（Rendering stage）。当然这些步骤不完全准确，现实中会更灵活些，每个步骤也不是都必须的。

###hello world
先做一个最简单的粒子系统。为尽量简单，粒子都是圆，质量都为1，并且不受力(没有加速度)，在2d平面上运动，初始化的时候产生一定数量的粒子，之后粒子数不增不减:

1、构建绘图环境:

画图先备纸。浏览器里有很多绘图环境（可以理解成纸和笔），我们选canvas。canvas即画布，是一堆像素和一些绘制方法的集合，我们可以在上面画任何东西。我们在html里定义好container（详见代码，不累述），然后用javascript取出container，在container容器里，放置一个和容器一样大的canvas，我们就可以在canvas上画图了。注意最后一行，canvas不能直接画图，必须取出ctx,画图的所有操作，都是在ctx上执行的。

这段代码是用原生的方法实现的（jquery等js库更方便），很简单，以后不重复写了。

```js
//创建画布，每个案例都差不多
var container = document.getElementById('container');//取得放置canvas画板的容器
var canvas = document.createElement('canvas');//创建canvas画布
canvas.width = container.offsetWidth;//把容器的宽度赋予画布
canvas.height = container.offsetHeight;//把容器的高度赋予画布
container.appendChild(canvas);//把画布放入容器
var ctx = canvas.getContext('2d');
```

2、粒子对象的设计

最好把每个粒子理解成对象，每个粒子都有自己的速度(x、y)、位置（vx、vy）、颜色(color)、半径(radius)的属性。这些都会初始化函数（构造函数）里完成，执行后，粒子对象就产生了，我们把粒子对象单独写成一个类，写在一个独立的文件（particle.js）里，这样不会产生很长很难读的代码。

```js
function Particle(ctx, x, y) {
  this.ctx = ctx;
  this.x = x;
  this.y = y;
  this.vx = Math.random();
  this.vy = Math.random();
  this.radius = Math.random() * 2;
  this.color = 'rgba(0,0,0,0.2)';
}
```

粒子对象还需包含将自己画出来的方法。回顾前面的流程，我们为粒子对象写两个方法:
update -> 模拟阶段（Simulation stage）
render -> 绘图阶段（Rendering stage）

update只是一些数值计算，电脑里绘图比算数慢，所以一般这个步骤是比较快的，如果这个步骤都卡，基本都会在下个过程里死机。
```js
Particle.prototype.update = function () {
  this.x = this.x + this.vx;
  this.y = this.y + this.vy;
};
```
render涉及到怎样把图画出来，所以选择不同的绘图方式，这个步骤的实现会有所不同。
```js
Particle.prototype.render = function () {
  var ctx = this.ctx;
  var radius = this.radius;//粒子的半径
  ctx.beginPath();//开始画图
  ctx.fillStyle = this.color;//设置填充色
  ctx.arc(this.x - radius, this.y - radius, radius, 0, Math.PI * 2);//画一个圆形
  ctx.fill();//填颜色
  ctx.closePath();//结束绘图
};
```

3、管理一堆粒子
当我们设计好单个的Particle的类，我们要在这个流程里管理所有粒子。我们目前的模型很简单，粒子初始化的时候一次性产生，然后通过

今天粒子系统已经变得非常复杂，从好莱坞的动作大片、中科院的流体模拟到我们h5页面的小小动画，都有各种粒子系统，但核心步骤差不多就是这样。这每一条原理都有无限的细化和分支，比如1、受力的方式决定了有许许多多不同的数学模型，他们有各自不同的效果，针对每种模型，又有许多不同的性能优化。又比如5、我们绘制点的方式有很多种，在web端，通过 svg、 vml、 canvas、 webgl都可以绘制点，他们在细节和功能会有很多不一样。


```js
var Particle = function(){
}
```

注意对于同一种粒子模型，绘图主要只是一个方法的差别，速度加速度更新神马都是一样的。


让我们进阶一步，看一个著名的简单问题，在17世纪，科学家发现牛顿定律竟然可以算天体运动，顿时觉得叼炸了。

模拟阶段 -> 渲染阶段
## 系统和单体
##### 把显示器的每个像素看做一个质点，电视机就是个粒子系统。在这个层面上，单个的粒子不重要，重要的是粒子和粒子间的联系，他们共同的行为形成了整体。
## GPU粒子
##### 在html中画点，svg可以支持5000个点，canvas可以画10万个点，但是更多呢？

有些参考资料不错
首先是shiffman的 [nature of code](http://natureofcode.com/)

我同事死马将粒子神速地将例子翻译成了[js版](https://github.com/dead-horse/the-nature-of-code-raphael)
